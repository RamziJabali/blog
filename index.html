<!DOCTYPE html>
<html>
<head>
<title>Ramzi's Blog</title>
    <style>
      table,
      th,
      td {
        padding: 10px;
        border: 1px solid black;
        border-collapse: collapse;
      }
    </style>
    <script>
    function show(shown) {
      document.getElementById(shown).style.display='block';
      return false;
    }
 </script>
	
 <script>
    function hideAll(){
      document.getElementByClassName(Blog).style.display='none';  
      return false;
    }
 </script>	
 
</head>
 
<body>
<div id ="TableOfContents">
<a href="#" onclick="return hideAll();">Hide All</a>	
<a href="#" onclick="return show('Blog1');">First Blog</a>
<a href="#" onclick="return show('Blog2');">Second Blog</a>
</div>

<div class="Blog" id="Blog1" style="display: none;">
	<p>07/04/21</p>

<p>In an attempt to learn Android development, I decided to do a simple tic-tac-toe game.</p>

<p>First realization:</p>

<p>I couldn't just open my computer and start coding the application, like I would usually be able to when coding a terminal based application. </p>

<p>With that realization came a question:</p>

<p>"How do you want the UI to look like"</p>

<p>I wanted to have a simple grid that the user could click on to mark the board with their player.</p>

<p>Upon answering that question, another came up in protest:</p>

<p>"How will you implement the UI"</p>

<p>With my basic knowledge of Android I listed all the different views I knew.</p>

<p>TextView</p>
<p>ButtonView</p>
<p>EditTextView</p>
<p>ImageView</p>
<p>GridView</p>

With that I made a table
<table style="width:100%">
  <tr>
    <th>View</th>
    <th>Pros</th>
    <th>Cons</th>
  </tr>
  <tr>
    <th>TextView</th>
    <th><li>Easy to implement</li></th>
    <th><li>Hard to customize</li>
	<li>Rows and Columns are not programmatically updated</li>
	<li>Looks ugly</li></th>
  </tr>
  <tr>
    <th>ButtonView</th>
    <th><li>Easy to implement</li></th>
    <th><li>Hard to customize</li>
	<li>Rows and Columns are not programmatically updated</li>
	<li>Extremely ugly</li></th>
  </tr>
  <tr>
    <th>EditTextView</th>
    <th><li>Easy to implement</li></th>
    <th><li>Unneeded feature</li>
	<li>Hard to customize</li>
	<li>Rows and Columns are not programmatically updated</li>
	<li>will Look extremely ugly</li></th>
  </tr>
  <tr>
    <th>ImageView</th>
    <th><li>looks good</li></th>
    <th><li>Hard to make look good</li>
	<li>Hard to customize</li>
	<li>Rows and Columns are not programmatically updated</li></th>
  </tr>
  <tr>
    <th>GridView</th>
    <th><li>looks good</li>
	<li>Rows/columns programmatically set</li>
	<li>Helps implement UI in neater fashion</li>
	<li>Easy to maintain</li></th>
    <th><li>Hard to make</li></th>
  </tr>
</table>

<p>My priorities for the application:</p>

<ol>
<li>UI</li>
<li>Programmatically set/updated attributes</li>
</ol>

<p>With the priorities in mind the clear winner was the GridView.</p>

<p>So I was going to create this application using the GridView, and the MVVM architecture.</p>

<p>First struggle:</p>

<p>I didn't know how to create a GridView, so as any person would do, I went to YouTube and StackOverFlow for answers.</p>

<p>I was bombarded with the same bad example over and over again, and left with a bit of working code and a bit of knowledge of what I was doing.</p>

<p>My first success came when I used GitHub's search feature to narrow down on similar code.</p>

<p>My second success was from reading articles about GridView, which shed light on what I had to do.</p>
 
<p>I was then able to construct a working piece of code that allowed me to see what I had done.</p>

<p>Combining the learning and searching techniques I found I was able to maximize my outcome and productivity.</p>

<p>Towards the end of the application I wanted to add unit testing so I went with JUnit for testing, but I realized it was not going to be as straightforward as unit testing in a terminal based application.</p>

<p>So with that in mind I had to find a library that would allow me to test my code in isolation without having to make a copy of the code to test separately. </p>

<p>After googling for a few minutes I saw Mockk.io pop up as a great library to use for testing code.</p>

<p>I tinkered with it for an hour or more in an attempt to understand how to use it, but that ended up being a hassle and all I had to do was open their documentation and use their listed example code.</p>

<p>After unit testing was added the application was working and all it needed was a bit of UI and code polishing in highlighted areas.</p>

<p>Once I finished polishing what needed polishing, I shipped it to GitHub marking the end of the program.</p>

<p>Lessons Learned:</p>

<uo>
<li>Search GitHub for example code</li>
<li>Read articles pertaining to the topic at hand</li>
<li>Read the documentation of a library you’re going to use</li>
<li>Spend contiguous hours working on a project to maximize output</li>
<li>Just because it works doesn’t means it’s finished</li>
</uo>
</div>


	<div class="Blog" id="Blog2" style="display: none;">
	<p>07/09/21</p>
<p>In this project my goal was to make API calls to a weather server, and populate the UI with several weather attributes.</p>

<p>I started this program by first adding the dependencies required for Okhttp and Retrofit.</p>
<p>Secondly I searched up a Youtube tutorial that would teach me the basics of Retrofit and Okhttp</p>

<p>While I was learning the basics I wanted to be able to apply it to to the project I wanted to make, so I looked for a weather API to use in my program</p>

<ol>
<li>Learn Retrofit</li>
<li>Learn Okhttp</li>
<li>Get an API to apply what I learned</li>
</ol>

<p>Once I had written the API endpoint managers, I tried right away to make the API call. Once I ran the application, it crashed. </p>

<p>After a couple of Google searches I realized that I was making the call on the main thread and that was the reason for the application crashing.</p>

<p>I remember here is where I started to get into the discussion of thread management. I didn’t know what a thread in this context even really was, so I decided to Google it and I was bombarded with 100 different answers. Just for sanity sake I boiled it down to, ability to run multiple sequences of code at the same time using different threads(single sequential flow of control within a program).</p>

<p>After that discovery I had to make an adjustment to the code to allow it to run on the background thread as opposed to the main thread. Running the API call in the main thread causes the application to crash because the UI also runs on it. The reason for the application crashing is because the API call might have to wait for a response, which causes the UI to to also wait which inturn causes it to freeze and crash.</p>

<p>The solution to that was using enqueue, which asynchronously sends a request and gets a callback of the result. Which is executed on the background thread! </p>

<p>Perfect, the application was up and running!</p>

<p>After that I changed the architecture to MVVM, added test cases, and added GitHub actions, finally the application was a wrap!</p>



<p>What did I learn</p>
<ol>
<li>Do NOT be intimidated by what you don’t know</li>
<li>Do NOT worry about all the little details</li>
<li>Get the application up and running, then worry about making it better</li>
</ol>
</div>

</body>
</html>
